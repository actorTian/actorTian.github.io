---
title: 探秘php多进程编程
date: 2016-04-09 17:31:19
tags: php
category: 技术
---

本人小说迷，基本在线看先说，被弹窗，小人图等信息刺激太大，决心自己造个阅读器，采用php多进程爬虫技术来丰满自己的库，并邮件自动更新提醒。到这里，就先要探秘一下php的多进程编程。基于LINUX的PHP扩展PCNTL可以提供多进程编程。再探寻过程中，发现多进程的问题处理上重点关注几个方面：
**1控制进程数量**
**2处理潜在产生僵尸进程或孤儿进程**
**3父进程阻塞难以获得更大的并发效果**
<!-- more -->

> PCNTL原理:FORK,FORK编程的大概原理是，每次调用fork函数，操作系统就会产生一个子进程，儿子进程所有的堆栈信息都是原封不动复制父进程的，而在fork之后，父进程与子进程实际上是相互独立的，父子进程不会相互影响。也就是说，fork调用位置之前的所有变量，父进程和子进程是一样的，但fork之后则取决于各自的动作，且数据也是独立的；因为数据已经完整的复制给了子进程。而唯一能够区分父子进程的方法就是判断fork的返回值。如果为0，表示是子进程，如果为正数，表示为父进程，且该正数为子进程的PID（进程号），而如果是-1，表示子进程创建失败。


### 举个栗子=》1.直接方式：pcntl.php
``` php
echo "parent start,pid".getmypid()."\n";
        say();
        for($i=0; $i<3; $i++){
                $pid = pcntl_fork();
                if($pid==-"-1"){
                        die("fork fail");
                }else if($pid > 0){
                        echo "parent here \n";
                        for($k=0; $k<2; $k++){
                                say();
                        }
                }else if($pid=="0"){
                        echo "child here,my pid is ".getmypid()."\n";
                        for($j=0; $j<5; $j++){
                                say();
                        }
                        exit;
                }
        }
        function say(){
                echo getmypid()."\t".date("y-m-d H:i:s",time())."\n";
                sleep(1);
        }
        ```

#### 结果：
``` vim
# php -f pcntl.php
parent start,pid110614
110614  16-08-05 11:54:43
parent here 
110614  16-08-05 11:54:44
child here,my pid is 110615
110615  16-08-05 11:54:44
110614  16-08-05 11:54:45
110615  16-08-05 11:54:45
parent here 
110614  16-08-05 11:54:46
110615  16-08-05 11:54:46
child here,my pid is 110616
110616  16-08-05 11:54:46
110614  16-08-05 11:54:47
110615  16-08-05 11:54:47
110616  16-08-05 11:54:47
parent here 
110614  16-08-05 11:54:48
110615  16-08-05 11:54:48
child here,my pid is 110617
110617  16-08-05 11:54:48
110616  16-08-05 11:54:48
110614  16-08-05 11:54:49
110617  16-08-05 11:54:49
110616  16-08-05 11:54:49
[root@localhost default]# 110617    16-08-05 11:54:50
110616  16-08-05 11:54:50
110617  16-08-05 11:54:51
110617  16-08-05 11:54:52
```
小结：创建了3个子进程，和父进程一起并行运行。但很容易因为两个进程同时进行写操作而造成冲突。


### 什么是僵尸进程？如何避免？
子进程结束时，父进程没有等待它（通过调用wait或者waitpid）,那么子进程结束后不会释放所有资源（浪费呀！），这种进程被称为僵尸进程，他里面存放了子进程结束时的相关数据，如果僵尸进程过多，会占用大量系统资源（如内存），影响机器性能。
用直接方式，父进程创建了子进程后，并没有等待子进程结束，二十继续运行。似乎这里看不到有什么问题。如果php脚本并不是运行完后自动结束，而是常驻内存的，就会造成子进程无法回收的问题。也就是僵尸进程。可以通过pcntl_wai()方法等待进程结束，然后回收已经结束的进程。
#### 栗子再来一个
``` vim
pcntl_signal(SIGCHLD, SIG_IGN); //如果父进程不关心子进程什么时候结束,子进程结束后，内核会回收。  
$pid = pcntl_fork();  
 if ($pid == -1){  
      ...  
} else if ($pid > 0){  
       echo "parent continue \n";  
       pcntl_wait($status);  //阻塞方式，多余并行有违初心
       //pcntl_wait($status,WNOHANG); //如果不想要阻塞进程注释掉上一句，开启此句等待子进程中断，防止子进程成为僵尸进程。  
       for ($k=0; $k<2; ++$k){  
            beep();  
      }  
} else if ($pid == 0){  
       ...  
}  ```




### 注意：
通过pcntl_XXX系列函数使用多进程功能。注意：pcntl_XXX只能运行在php CLI（命令行）环境下，在web服务器环境下，会出现无法预期的结果，请慎用！
附加：进程之间如何通信？
