---
title: 乐观锁和悲观锁
date: 2017-01-13 21:35:54
tags: [php,并发]
category: 技术
---
并发写入，是每个开发人员的必备核心技能之一。在并发环境下，有可能会出现脏读（Dirty Read）、不可重复读（UnrepeatableRead）、幻读（PhantomRead）、更新丢失（Lost update）等情况。
为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。但是，就于具体开发过程而言，一般分为悲观锁和乐观锁两种方式来解决并发冲突问题。

### 乐观锁
乐观锁（optimistic locking）表现出大胆、务实的态度。使用乐观锁的前提是， 实际应用当中，发生冲突的概率比较低。他的设计和实现直接而简洁。目前Web应用中，乐观锁的使用占有绝对优势。

<!-- more -->
#### 处理逻辑，最常用的乐观锁处理方式是采用版本号方式处理。如下:
1. 读取要更新的记录。
2. 对记录按照用户的意愿进行修改。当然，这个时候不会修改ver字段。这个字段对用户是没意义的。
3. 在保存记录前，再次读取这个记录的 ver 字段，与之前读取的值进行比对。
如果 ver 不同，说明在用户修改过程中，这个记录被别人改动过了。那么， 我们要给出提示。
4. 如果 ver 相同，说明这个记录未被修改过。那么，对 ver ＋1， 并保存这个记录。这样子就完成了记录的更新。同时，该记录的版本号也加了1。

#### 乐观锁失效
乐观锁存在失效的情况，属小概率事件，需要多个条件共同配合才会出现。如：
1. 应用采用自己的策略管理主键ID。如，常见的取当前ID字段的最大值＋1作为新ID。
2. 版本号字段 ver 默认值为 0 。
3. 用户A读取了某个记录准备修改它。该记录正好是ID最大的记录，且之前没被修改过， ver 为默认值 0。
4. 在用户A读取完成后，用户B恰好删除了该记录。之后，用户C又插入了一个新记录。
5. 此时，阴差阳错的，新插入的记录的ID与用户A读取的记录的ID是一致的， 而版本号两者又都是默认值 0。
6. 用户A在用户C操作完成后，修改完成记录并保存。由于ID、ver均可以匹配上， 因此用户A成功保存。但是，却把用户C插入的记录覆盖掉了。

改进：使用时间戳作为版本号字段，精确到毫秒级别。但是仍有失效的可能，且使用高精度时间戳的话，成本比较高。

### 悲观锁
悲观锁提现了一种严谨的处事态度，实现相对来说成本高一些。

#### 悲观锁处理逻辑：
1. 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
2. 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。悲观锁确实很严谨，有效保证了数据的一致性，在C/S应用上有诸多成熟方案。 

#### 悲观锁的缺点：
但是他的缺点与优点一样的明显：
悲观锁适用于可靠的持续性连接，诸如C/S应用。 对于Web应用的HTTP连接，先天不适用。
锁的使用意味着性能的损耗，在高并发、锁定持续时间长的情况下，尤其严重。 Web应用的性能瓶颈多在数据库处，使用悲观锁，进一步收紧了瓶颈。非正常中止情况下的解锁机制，设计和实现起来很麻烦，成本还很高。不够严谨的设计下，可能产生莫名其妙的，不易被发现的， 让人头疼到想把键盘一巴掌碎的死锁问题。

